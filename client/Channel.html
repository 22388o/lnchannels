<!-- @format -->

<script>
  import {onMount, getContext} from 'svelte'
  import {abbr, date} from './helpers'
  import NotFound from './NotFound.html'
  import NodeAlias from './NodeAlias.html'

  var notfound = false
  var channel = {
    short_channel_id: 'loading',
    nodes: ['', ''],
    onchain: {open: {}, close: {}}
  }
  var upwardpolicies = []
  var downwardpolicies = []
  var stats = {}

  $: htlcs = channel.onchain.close.htlcs
    ? channel.onchain.close.htlcs.a
        .map(htlc => ({...htlc, owner: 'a'}))
        .concat(
          channel.onchain.close.htlcs.b.map(htlc => ({...htlc, owner: 'b'}))
        )
        .map((htlc, i) => {
          if (channel.onchain.a) {
            htlc.owner = channel.nodes[channel.onchain[htlc.owner]]
          } else if (channel.onchain.closer) {
            htlc.owner =
              htlc.owner === channel.onchain.closer
                ? 'the one who closed'
                : "the one who didn't close"
          } else if (channel.onchain.close.htlcs.a.length) {
            htlc.owner = htlc.owner === 'a' ? 'someone' : 'someone else'
          } else {
            htlc.owner = 'unknown'
          }
          return htlc
        })
    : []
  $: closebalances = channel.onchain.a
    ? channel.nodes
        .map((_, idx) => (channel.onchain.a === idx ? 'a' : 'b'))
        .map(letter => channel.onchain.close.balance[letter])
    : null

  const id = getContext('history')
    .location.pathname.split('/')
    .slice(-1)[0]

  onMount(async () => {
    stats = await getContext('stats')
  })

  onMount(async () => {
    let res = await (
      await fetch(`/api/channels?short_channel_id=eq.${id}`)
    ).json()
    if (res.length === 0) {
      notfound = true
    } else {
      channel = res[0]
    }
  })

  onMount(async () => {
    let policies = await (
      await fetch(
        `/api/policies?short_channel_id=eq.${id}&select=direction,base_fee_millisatoshi,fee_per_millionth,delay,update_time`
      )
    ).json()

    for (let i = 0; i < policies.length; i++) {
      let policy = policies[i]
      ;[downwardpolicies, upwardpolicies][policy.direction].push(policy)
    }
  })
</script>

<svelte:head>
  <title>channel {channel.short_channel_id}</title>
  <meta
    name="description"
    content="Information about the Lightning Network channel {channel.short_channel_id} between {channel.nodes[0]} and {channel.nodes[1]}"
  />
</svelte:head>

{#if notfound}
<NotFound />
{:else}
<div>
  <h1>
    channel
    <pre class="id" class:closed="{channel.onchain.close.block}">
    {channel.short_channel_id}
  </pre
    >
  </h1>

  <h4>details</h4>
  <table>
    <tr>
      <th>short_channel_id</th>
      <td>{channel.short_channel_id}</td>
    </tr>
    <tr>
      <th>satoshis</th>
      <td>{channel.satoshis}</td>
    </tr>
    {#if channel.onchain.funder}
    <tr>
      <th>funder</th>
      <td>
        <NodeAlias pubkey="{channel.nodes[channel.onchain.funder]}" />
      </td>
    </tr>

    {/if}
    <tr>
      <th>nodes</th>
      <td>
        <table>
          <tr>
            <td>
              <NodeAlias pubkey="{channel.nodes[0]}" />
            </td>
            <td>
              <NodeAlias pubkey="{channel.nodes[1]}" />
            </td>
          </tr>
          <tr>
            <td>
              <a href="/node/{channel.nodes[0]}">{abbr(channel.nodes[0])}</a>
            </td>
            <td>
              <a href="/node/{channel.nodes[1]}">{abbr(channel.nodes[1])}</a>
            </td>
          </tr>
          {#if closebalances}
          <tr>
            <td>
              {closebalances[0]} sat
            </td>
            <td>
              {closebalances[1]} sat
            </td>
          </tr>
          {/if}
        </table>
      </td>
    </tr>
    <tr>
      <th>duration</th>
      <td>
        {#if channel.onchain.close.block} {channel.onchain.close.block -
        channel.onchain.open.block} blocks
        <i
          class="bar"
          style="width:{100 * (channel.onchain.close.block - channel.onchain.open.block) / stats.max_channel_duration}%; background: var(--gold)"
        />
        {:else} {stats.last_block - channel.onchain.open.block} blocks and
        counting
        <i
          class="bar"
          style="width:{100 * (stats.last_block - channel.onchain.open.block) / stats.max_channel_duration}%; background: var(--gold)"
        />
        {/if}
      </td>
    </tr>
    {#if channel.onchain.close.type}
    <tr>
      <th>close type</th>
      <td>
        {channel.onchain.close.type} {#if channel.onchain.close.balance.b ==
        0}(unused){/if}
      </td>
    </tr>
    {/if} {#if channel.onchain.closer && channel.onchain.a}
    <tr>
      <th>force closer</th>
      <td>
        <NodeAlias
          pubkey="{channel.nodes[channel.onchain[channel.onchain.closer]]}"
        />
      </td>
    </tr>
    {/if} {#if htlcs.length}
    <tr>
      <th>HTLCs</th>
      <td>
        <table>
          <tr>
            <th>offered to</th>
            <th>sat</th>
            <th>result</th>
          </tr>
          {#each htlcs as htlc}
          <tr>
            <td>{htlc.owner}</td>
            <td>{htlc.amount}</td>
            <td>{htlc.kind}</td>
          </tr>
          {/each}
        </table>
      </td>
    </tr>
    {/if}
  </table>

  {#if upwardpolicies.length || downwardpolicies.length}
  <h4>policy details</h4>
  <div style="display: flex">
    {#if upwardpolicies.length}
    <table>
      <caption>
        from
        <code>
          <NodeAlias pubkey="{channel.nodes[0]}" />
        </code>
      </caption>
      <thead>
        <tr>
          <th>min fee</th>
          <th>fee %</th>
          <th>delay</th>
          <th>update</th>
        </tr>
      </thead>
      <tbody>
        {#each upwardpolicies as policy}
        <tr>
          <td>{policy.base_fee_millisatoshi / 1000} sat</td>
          <td>{policy.fee_per_millionth / 10000}</td>
          <td>{policy.delay}</td>
          <td>{date(policy.update_time)}</td>
        </tr>
        {/each}
      </tbody>
    </table>
    {/if} {#if downwardpolicies.length}
    <table>
      <caption>
        from
        <code>
          <NodeAlias pubkey="{channel.nodes[1]}" />
        </code>
      </caption>
      <thead>
        <tr>
          <th>min fee</th>
          <th>fee %</th>
          <th>delay</th>
          <th>update</th>
        </tr>
      </thead>
      <tbody>
        {#each downwardpolicies as policy}
        <tr>
          <td>{policy.base_fee_millisatoshi / 1000} sat</td>
          <td>{policy.fee_per_millionth / 10000}</td>
          <td>{policy.delay}</td>
          <td>{date(policy.update_time)}</td>
        </tr>
        {/each}
      </tbody>
    </table>
    {/if}
  </div>
  {:else}
  <br />
  {/if}

  <h4>onchain transactions</h4>
  <table>
    <tr>
      <th></th>
      <th>block</th>
      <th>transaction</th>
      <th>fee paid</th>
    </tr>
    <tr>
      <th>open</th>
      <td>
        <a
          href="https://blockstream.info/block/{channel.onchain.open.block}"
          title="{channel.onchain.open.time}"
        >
          {channel.onchain.open.block}
        </a>
      </td>
      <td>
        <a
          href="https://blockstream.info/tx/{channel.onchain.open.txid}?output:{channel.short_channel_id.split('x')[2]}"
        >
          {channel.onchain.open.txid}
        </a>
      </td>
      <td>{channel.onchain.open.fee} sat</td>
    </tr>
    {#if channel.onchain.close.block}
    <tr>
      <th>close</th>
      <td>
        <a
          href="https://blockstream.info/block/{channel.onchain.close.block}"
          title="{channel.onchain.close.time}"
        >
          {channel.onchain.close.block}
        </a>
      </td>
      <td>
        <a href="https://blockstream.info/tx/{channel.onchain.close.txid}">
          {channel.onchain.close.txid}
        </a>
      </td>
      <td>{channel.onchain.close.fee} sat</td>
    </tr>
    {/if}
  </table>
</div>
{/if}
