<!-- @format -->

<script>
  import {onMount, getContext} from 'svelte'
  import {abbr, date} from './helpers'

  import NodeHistory from './charts/NodeHistory.html'
  import Bubbles from './charts/Bubbles.html'

  var loading = true

  var node = {}
  var aliases = []
  var channels = []

  var maxfee = 0
  var maxcap = 0

  const id = getContext('history')
    .location.pathname.split('/')
    .slice(-1)[0]

  // toggle incoming-outgoing fee policy display
  var direction = 'outgoing'
  function toggleDirection(e) {
    e.preventDefault()
    direction = direction === 'outgoing' ? 'incoming' : 'outgoing'
  }

  onMount(async () => {
    let res = await Promise.all([
      fetch(`/api/nodes?pubkey=eq.${id}`).then(r => r.json()),
      fetch(
        `/api/nodealiases?pubkey=eq.${id}&select=first_seen,alias`
      ).then(r => r.json()),
      fetch(`/api/rpc/node_channels?pubkey=${id}`).then(r => r.json())
    ])

    loading = false

    node = res[0][0]
    aliases = res[1]
    channels = res[2]

    node.name = node.alias ? `"${node.alias}"` : abbr(node.pubkey)

    for (let i = channels.length - 1; i >= 0; i--) {
      // data for the microcharts later
      let chan = channels[i]
      let fee = chan.open_fee + (chan.close_fee || 0)
      maxfee = fee > maxfee ? fee : maxfee
      maxcap = chan.satoshis > maxcap ? chan.satoshis : maxcap
    }

    // channels list (insert close events in the list)
    // var closeevents = []
    // let trchannels = document
    //   .getElementById('channels-table')
    //   .querySelectorAll('tbody tr')
    // for (let i = 0; i < trchannels.length; i++) {
    //   if (trchannels[i].classList.contains('closed')) {
    //     let scid = trchannels[i].id.slice(3)
    //     let closeblock = trchannels[i].children[5].innerText.trim()
    //     if (closeevents.length && closeevents[0].block === scid) {
    //       closeevents[0].channels.push(scid)
    //     } else {
    //       closeevents.push({block: closeblock, channels: [scid]})
    //     }
    //   }
    // }

    // closeevents.sort((a, b) => parseInt(a.block) - parseInt(b.block))

    // // go from bottom to top inserting the rows correspondent to close events
    // for (let i = trchannels.length - 2; i >= 0; i--) {
    //   let trbefore = trchannels[i + 1]
    //   let block = parseInt(trchannels[i].children[4].innerText.trim())
    //   while (parseInt(closeevents[0].block) < block) {
    //     trbefore = insertCloseEventRow(trbefore, closeevents.shift())
    //   }
    //   if (closeevents.length === 0) break
    // }

    // // do the same as above, but for the last/upmost row
    // let trbefore = trchannels[0]
    // let block = 9999999
    // while (parseInt(closeevents[0].block) < block) {
    //   trbefore = insertCloseEventRow(trbefore, closeevents.shift())
    // }

    // function insertCloseEventRow(before, ev) {
    //   let closedblock = ev.block
    //   let closedscids = ev.channels
    //   var trclose = document.createElement('tr')
    //   trclose.className = 'close-event'
    //   trclose.innerHTML = `<td colspan="4">
    //         closed: ${closedscids
    //           .map(c => `<a href="#ch-${c}">${c}</a>`)
    //           .join(', ')
    //           .replace(/\, ([^,]+)$/, (comma, rest) => ' and ' + rest)}
    //       </td>
    //       <td>${closedblock}</td>
    //       <td colspan="2"></td>
    //       `
    //   before.parentNode.insertBefore(trclose, before)
    //   return trclose
    // }
  })
</script>

<style>
  .col-incoming {
    display: none;
  }
  .col-outgoing {
    display: none;
  }

  #channels-bubble .highcharts-point {
    fill: var(--gold);
  }
  #channels-bubble .highcharts-point,
  #channels-bubble .highcharts-data-label {
    cursor: pointer;
  }

  tr.close-event {
    background-color: #e8dcdc;
    opacity: 0.7;
  }
  #channels-table tr.close-event td {
    padding-top: 0;
    padding-bottom: 0;
    padding-left: 20px;
  }
</style>

<svelte:head>
  <title>node {node.alias}</title>
  <meta
    name="description"
    content="{abbr(node.pubkey)}: {node.openchannels} channels, total capacity of {node.capacity} satoshis"
  />
</svelte:head>

{#if loading} loading {:else}
<h1>
  node
  <pre class="id">{node.pubkey}</pre>
</h1>

<div class="flex-col">
  {#if aliases}
  <div>
    <h4>node names</h4>
    <table>
      <thead>
        <tr>
          <th>first seen</th>
          <th>alias</th>
        </tr>
      </thead>
      <tbody>
        {#each aliases as alias}
        <tr>
          <td>{date(alias.first_seen)}</td>
          <td>{alias.alias}</td>
        </tr>
        {/each}
      </tbody>
    </table>
  </div>
  {/if}

  <div>
    <table>
      <tbody>
        <tr>
          <th>open channels</th>
          <td>{node.openchannels}</td>
        </tr>
        <tr>
          <th>closed channels</th>
          <td>{node.closedchannels}</td>
        </tr>
        <tr>
          <th>avg channel duration</th>
          <td>{node.avg_duration}</td>
        </tr>
        <tr>
          <th>avg opening fee</th>
          <td>{node.avg_open_fee}</td>
        </tr>
        <tr>
          <th>avg closing fee</th>
          <td>{node.avg_close_fee}</td>
        </tr>
        <tr>
          <th>capacity</th>
          <td>{node.capacity}</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<NodeHistory channels="{channels}" />
<Bubbles channels="{channels}" />
<div>
  <h4>all channels</h4>
  <table id="channels-table">
    <thead>
      <tr>
        <th>with</th>
        <th>id</th>
        <th>total satoshis</th>
        <th>chain fee</th>
        <th>open</th>
        <th>close</th>
        <th>
          {#if direction == "outgoing"} ↗ {:else} ↙ {/if}
          <span class="toggle" on:click="{toggleDirection}">
            {direction}
          </span>
          fee policy
        </th>
      </tr>
    </thead>
    <tbody>
      {#each channels as channel}
      <tr
        id="ch-{channel.short_channel_id}"
        class:closed="{channel.close_block > 0}"
      >
        <td data-size="{channel.peer_size}">
          <a href="/node/{channel.peer_id}">
            {#if channel.peer_name} {channel.peer_name} {:else}
            {abbr(channel.peer_id)} {/if}
          </a>
        </td>
        <td>
          <a href="/channel/{channel.short_channel_id}">
            {channel.short_channel_id}
          </a>
        </td>
        <td>
          {channel.satoshis}
          <i
            class="bar"
            style="width:{(100 * (channel.satoshis / maxcap)).toFixed(2)}%; background: var(--gold)"
          />
        </td>
        <td
          title="{(100 * (channel.open_fee + channel.close_fee) / channel.satoshis).toFixed(2)}% of total value"
        >
          {channel.open_fee} {#if channel.close_block > 0} + {channel.close_fee}
          = {channel.open_fee + channel.close_fee} {/if}

          <i
            class="bar"
            style="width:{(100 * (channel.open_fee + channel.close_fee) / maxfee).toFixed(2)}%; background: var(--gold)"
          />
        </td>
        <td>{channel.open_block}</td>
        <td>{#if channel.close_block > 0} {channel.close_block} {/if}</td>
        {#if channel.close_block > 0}
        <td>
          {#if channel.close_type}closed as
          <strong>{channel.close_type}</strong>{/if} {#if
          channel.close_htlc_count > 0}with {channel.close_htlc_count} HTLC{#if
          channel.close_htlc_count != 1}s{/if} {/if}
        </td>
        {:else}
        <td class:hidden="{direction !== 'outgoing'}">
          {channel.outgoing_fee_per_millionth / 10000}% (min
          {(channel.outgoing_base_fee_millisatoshi / 1000).toFixed(3)} sat);
          delay of {channel.outgoing_delay}
        </td>
        <td class:hidden="{direction !== 'incoming'}">
          {channel.incoming_fee_per_millionth / 10000}% (min
          {(channel.incoming_base_fee_millisatoshi / 1000).toFixed(3)} sat);
          delay of {channel.incoming_delay}
        </td>
        {/if}
      </tr>
      {/each}
    </tbody>
  </table>
</div>
{/if}
