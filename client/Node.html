<!-- @format -->

<script>
  import {onMount, getContext} from 'svelte'
  import {abbr, date} from './helpers'
  import NotFound from './NotFound.html'
  import NodeHistory from './charts/NodeHistory.html'
  import Bubbles from './charts/Bubbles.html'

  var notfound = false
  var node = {
    pubkey: 'loading',
    alias: ''
  }
  var aliases = []
  var channels = null

  var maxfee = 0
  var maxcap = 0

  const id = getContext('history')
    .location.pathname.split('/')
    .slice(-1)[0]

  // toggle incoming-outgoing fee policy display
  var direction = 'outgoing'
  function toggleDirection(e) {
    e.preventDefault()
    direction = direction === 'outgoing' ? 'incoming' : 'outgoing'
  }

  onMount(async () => {
    channels = await (
      await fetch(`/api/rpc/node_channels?nodepubkey=${id}`)
    ).json()

    for (let i = channels.length - 1; i >= 0; i--) {
      // data for the microcharts later
      let chan = channels[i]
      let fee = chan.open.fee + (chan.close.fee || 0)
      maxfee = fee > maxfee ? fee : maxfee
      maxcap = chan.satoshis > maxcap ? chan.satoshis : maxcap
    }

    // channels list (insert close events in the list)
    // var closeevents = []
    // let trchannels = document
    //   .getElementById('channels-table')
    //   .querySelectorAll('tbody tr')
    // for (let i = 0; i < trchannels.length; i++) {
    //   if (trchannels[i].classList.contains('closed')) {
    //     let scid = trchannels[i].id.slice(3)
    //     let closeblock = trchannels[i].children[5].innerText.trim()
    //     if (closeevents.length && closeevents[0].block === scid) {
    //       closeevents[0].channels.push(scid)
    //     } else {
    //       closeevents.push({block: closeblock, channels: [scid]})
    //     }
    //   }
    // }

    // closeevents.sort((a, b) => parseInt(a.block) - parseInt(b.block))

    // // go from bottom to top inserting the rows correspondent to close events
    // for (let i = trchannels.length - 2; i >= 0; i--) {
    //   let trbefore = trchannels[i + 1]
    //   let block = parseInt(trchannels[i].children[4].innerText.trim())
    //   while (parseInt(closeevents[0].block) < block) {
    //     trbefore = insertCloseEventRow(trbefore, closeevents.shift())
    //   }
    //   if (closeevents.length === 0) break
    // }

    // // do the same as above, but for the last/upmost row
    // let trbefore = trchannels[0]
    // let block = 9999999
    // while (parseInt(closeevents[0].block) < block) {
    //   trbefore = insertCloseEventRow(trbefore, closeevents.shift())
    // }

    // function insertCloseEventRow(before, ev) {
    //   let closedblock = ev.block
    //   let closedscids = ev.channels
    //   var trclose = document.createElement('tr')
    //   trclose.className = 'close-event'
    //   trclose.innerHTML = `<td colspan="4">
    //         closed: ${closedscids
    //           .map(c => `<a href="#ch-${c}">${c}</a>`)
    //           .join(', ')
    //           .replace(/\, ([^,]+)$/, (comma, rest) => ' and ' + rest)}
    //       </td>
    //       <td>${closedblock}</td>
    //       <td colspan="2"></td>
    //       `
    //   before.parentNode.insertBefore(trclose, before)
    //   return trclose
    // }
  })

  onMount(async () => {
    let res = await (await fetch(`/api/nodes?pubkey=eq.${id}`)).json()
    if (res.length === 0) {
      notfound = true
    } else {
      node = res[0]
    }
  })

  onMount(async () => {
    aliases = await (
      await fetch(`/api/nodealiases?pubkey=eq.${id}&select=first_seen,alias`)
    ).json()
  })
</script>

<style>
  .col-incoming {
    display: none;
  }
  .col-outgoing {
    display: none;
  }

  #channels-bubble .highcharts-point {
    fill: var(--gold);
  }
  #channels-bubble .highcharts-point,
  #channels-bubble .highcharts-data-label {
    cursor: pointer;
  }

  tr.close-event {
    background-color: #e8dcdc;
    opacity: 0.7;
  }
  #channels-table tr.close-event td {
    padding-top: 0;
    padding-bottom: 0;
    padding-left: 20px;
  }
</style>

<svelte:head>
  <title>node {node.alias}</title>
  <meta
    name="description"
    content="{abbr(node.pubkey)}: {node.openchannels} channels, total capacity of {node.capacity} satoshis"
  />
</svelte:head>

{#if notfound}
<NotFound />
{:else}
<div>
  <h1>
    node {node.alias}
    <pre class="id">{node.pubkey}</pre>
  </h1>

  <div class="flex-col">
    {#if aliases.length > 0}
    <div>
      <h4>node names</h4>
      <table>
        <thead>
          <tr>
            <th>first seen</th>
            <th>alias</th>
          </tr>
        </thead>
        <tbody>
          {#each aliases as alias}
          <tr>
            <td>{date(alias.first_seen)}</td>
            <td>{alias.alias}</td>
          </tr>
          {/each}
        </tbody>
      </table>
    </div>
    {/if}

    <div>
      <table>
        <tbody>
          <tr>
            <th>open channels</th>
            <td>{node.openchannels}</td>
          </tr>
          <tr>
            <th>closed channels</th>
            <td>{node.closedchannels}</td>
          </tr>
          <tr>
            <th>avg channel duration</th>
            <td>{node.avg_duration}</td>
          </tr>
          <tr>
            <th>avg opening fee</th>
            <td>{node.avg_open_fee}</td>
          </tr>
          <tr>
            <th>avg closing fee</th>
            <td>{node.avg_close_fee}</td>
          </tr>
          <tr>
            <th>capacity</th>
            <td>{node.capacity}</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  {#if channels}
  <NodeHistory channels="{channels}" />
  <Bubbles channels="{channels}" />
  <div>
    <h4>all channels</h4>
    <table id="channels-table">
      <thead>
        <tr>
          <th>with</th>
          <th>id</th>
          <th>total satoshis</th>
          <th>chain fee</th>
          <th>open</th>
          <th>close</th>
          <th>
            {#if direction == "outgoing"} ↗ {:else} ↙ {/if}
            <span class="toggle" on:click="{toggleDirection}">
              {direction}
            </span>
            fee policy
          </th>
        </tr>
      </thead>
      <tbody>
        {#each channels as channel}
        <tr
          id="ch-{channel.short_channel_id}"
          class:closed="{channel.close.block > 0}"
        >
          <td data-size="{channel.peer.size}">
            <a href="/node/{channel.peer.id}">
              {#if channel.peer.name} {channel.peer.name} {:else}
              {abbr(channel.peer.id)} {/if}
            </a>
          </td>
          <td>
            <a href="/channel/{channel.short_channel_id}">
              {channel.short_channel_id}
            </a>
          </td>
          <td>
            {channel.satoshis}
            <i
              class="bar"
              style="width:{(100 * (channel.satoshis / maxcap)).toFixed(2)}%; background: var(--gold)"
            />
          </td>
          <td
            title="{(100 * (channel.open.fee + channel.close.fee) / channel.satoshis).toFixed(2)}% of total value"
          >
            {channel.open.fee} {#if channel.close.block > 0} +
            {channel.close.fee} = {channel.open.fee + channel.close.fee} {/if}

            <i
              class="bar"
              style="width:{(100 * (channel.open.fee + channel.close.fee) / maxfee).toFixed(2)}%; background: var(--gold)"
            />
          </td>
          <td>{channel.open.block}</td>
          <td>
            {#if channel.close.block > 0} {channel.close.block} {/if}
          </td>
          {#if channel.close.block > 0}
          <td>
            {#if channel.close.type}closed as
            <strong>{channel.close.type}</strong>{/if}
          </td>
          {:else}
          <td class:hidden="{direction !== 'outgoing'}">
            {channel.outpol.rate / 10000}% (min {(channel.outpol.base /
            1000).toFixed(3)} sat); delay of {channel.outpol.delay}
          </td>
          <td class:hidden="{direction !== 'incoming'}">
            {channel.inpol.rate / 10000}% (min {(channel.inpol.base /
            1000).toFixed(3)} sat); delay of {channel.inpol.delay}
          </td>
          {/if}
        </tr>
        {/each}
      </tbody>
    </table>
  </div>
  {/if}
</div>
{/if}
