<!-- @format -->

<script>
  import {onMount, getContext} from 'svelte'
  import {abbr, date, plotOptions} from './helpers'

  var node = {}
  var aliases = []
  var channels = []
  var stats = {}

  var maxfee = 0
  var maxcap = 0

  var chartBubbles
  var chartHistory

  const id = getContext('history')
    .location.pathname.split('/')
    .slice(-1)[0]

  // toggle incoming-outgoing fee policy display
  var direction = 'outgoing'
  function toggleDirection(e) {
    e.preventDefault()
    direction = direction === 'outgoing' ? 'incoming' : 'outgoing'
  }

  onMount(async () => {
    stats = await getContext('stats')

    let res = await Promise.all([
      fetch(`/api/nodes?pubkey=eq.${id}`).then(r => r.json()),
      fetch(
        `/api/nodealiases?pubkey=eq.${id}&select=first_seen,alias`
      ).then(r => r.json()),
      fetch(`/api/rpc/node_channels?pubkey=${id}`).then(r => r.json())
    ])
    node = res[0][0]
    aliases = res[1]
    channels = res[2]

    node.name = node.alias ? `"${node.alias}"` : abbr(node.pubkey)

    // gather info
    var blockmap = {}
    var opens = {}
    var closes = {}
    var open_sats = {}
    var close_sats = {}
    var openchannelsbubbles = []

    for (let i = channels.length - 1; i >= 0; i--) {
      let chan = channels[i]

      // gather data for the chart
      opens[chan.open_block] = opens[chan.open_block] || 0
      open_sats[chan.open_block] = open_sats[chan.open_block] || 0
      opens[chan.open_block]++
      open_sats[chan.open_block] += chan.satoshis
      blockmap[chan.open_block] = true

      if (chan.close_block) {
        // if it's closed gather close data
        closes[chan.close_block] = closes[chan.close_block] || 0
        close_sats[chan.close_block] = close_sats[chan.close_block] || 0
        closes[chan.close_block]++
        close_sats[chan.close_block] += chan.satoshis
        blockmap[chan.close_block] = true
      } else {
        // if it's open add to bubble chart
        openchannelsbubbles.push({
          x: chan.open_block,
          y: chan.satoshis,
          z: chan.peer_size,
          name: chan.peer_name,
          scid: chan.short_channel_id
        })
      }

      // data for the microcharts later
      let fee = chan.open_fee + (chan.close_fee || 0)
      maxfee = fee > maxfee ? fee : maxfee
      maxcap = chan.satoshis > maxcap ? chan.satoshis : maxcap
    }

    // insert last block if not exists (so the chart is not stuck in a past position)
    if (!(stats.last_block in blockmap)) {
      blockmap[stats.last_block] = true
    }

    // make main chart
    let blocks = Object.keys(blockmap).sort()
    var openings = []
    var closings = []
    var total = []
    var capacity = []

    for (let i = 0; i < blocks.length; i++) {
      let b = blocks[i]
      let x = parseInt(b)
      openings.push([x, opens[b] || 0])
      closings.push([x, closes[b] || 0])
      total.push([
        x,
        (total.length > 0 ? total[i - 1][1] : 0) +
          (opens[b] || 0) -
          (closes[b] || 0)
      ])
      capacity.push([
        x,
        (capacity.length > 0 ? capacity[i - 1][1] : 0) +
          (open_sats[b] || 0) -
          (close_sats[b] || 0)
      ])
    }

    H.chart(chartHistory, {
      title: {text: ''},
      yAxis: [{visible: false}, {visible: false}, {visible: false}],
      series: [
        {
          name: 'capacity (sat)',
          type: 'area',
          data: capacity,
          step: 'left',
          yAxis: 2,
          color: 'var(--gold)'
        },
        {
          name: 'total',
          type: 'area',
          data: total,
          step: 'left',
          yAxis: 1,
          color: 'var(--blue)'
        },
        {
          name: 'openings',
          type: 'column',
          data: openings,
          yAxis: 0,
          color: 'var(--green)',
          borderWidth: 1
        },
        {
          name: 'closings',
          type: 'column',
          data: closings,
          yAxis: 0,
          color: 'var(--red)',
          borderWidth: 1
        }
      ],
      plotOptions
    })

    // channel bubbles
    H.chart(chartBubbles, {
      title: {text: ''},
      yAxis: [{title: {text: 'channel size (sat)', enabled: null}, floor: 0}],
      series: [
        {
          type: 'bubble',
          data: openchannelsbubbles,
          marker: {fillColor: 'var(--gold)'},
          showInLegend: false,
          minSize: '1%',
          maxSize: '30%',
          sizeBy: 'width',
          dataLabels: {
            enabled: true,
            format: '{point.name}',
            style: {
              color: 'black',
              textOutline: 'none',
              fontWeight: 'normal'
            }
          },
          tooltip: {
            headerFormat: '',
            followPointer: true,
            followTouchMove: true,
            pointFormat: '{point.name}: {point.y}',
            valueSuffix: ' sat'
          },
          events: {
            click: e => {
              document.getElementById(`ch-${e.point.scid}`).scrollIntoView({
                behavior: 'smooth',
                block: 'start',
                inline: 'nearest'
              })
            }
          }
        }
      ]
    })

    // channels list (insert close events in the list)
    // var closeevents = []
    // let trchannels = document
    //   .getElementById('channels-table')
    //   .querySelectorAll('tbody tr')
    // for (let i = 0; i < trchannels.length; i++) {
    //   if (trchannels[i].classList.contains('closed')) {
    //     let scid = trchannels[i].id.slice(3)
    //     let closeblock = trchannels[i].children[5].innerText.trim()
    //     if (closeevents.length && closeevents[0].block === scid) {
    //       closeevents[0].channels.push(scid)
    //     } else {
    //       closeevents.push({block: closeblock, channels: [scid]})
    //     }
    //   }
    // }

    // closeevents.sort((a, b) => parseInt(a.block) - parseInt(b.block))

    // // go from bottom to top inserting the rows correspondent to close events
    // for (let i = trchannels.length - 2; i >= 0; i--) {
    //   let trbefore = trchannels[i + 1]
    //   let block = parseInt(trchannels[i].children[4].innerText.trim())
    //   while (parseInt(closeevents[0].block) < block) {
    //     trbefore = insertCloseEventRow(trbefore, closeevents.shift())
    //   }
    //   if (closeevents.length === 0) break
    // }

    // // do the same as above, but for the last/upmost row
    // let trbefore = trchannels[0]
    // let block = 9999999
    // while (parseInt(closeevents[0].block) < block) {
    //   trbefore = insertCloseEventRow(trbefore, closeevents.shift())
    // }

    // function insertCloseEventRow(before, ev) {
    //   let closedblock = ev.block
    //   let closedscids = ev.channels
    //   var trclose = document.createElement('tr')
    //   trclose.className = 'close-event'
    //   trclose.innerHTML = `<td colspan="4">
    //         closed: ${closedscids
    //           .map(c => `<a href="#ch-${c}">${c}</a>`)
    //           .join(', ')
    //           .replace(/\, ([^,]+)$/, (comma, rest) => ' and ' + rest)}
    //       </td>
    //       <td>${closedblock}</td>
    //       <td colspan="2"></td>
    //       `
    //   before.parentNode.insertBefore(trclose, before)
    //   return trclose
    // }
  })
</script>

<style>
  .toggle {
    cursor: pointer;
    text-decoration: none;
    border-style: dotted;
    border-width: 0 0 3px 0;
  }
  .toggle {
    border-style: dashed;
  }
  .col-incoming {
    display: none;
  }
  .col-outgoing {
    display: none;
  }

  #channels-bubble .highcharts-point {
    fill: var(--gold);
  }
  #channels-bubble .highcharts-point,
  #channels-bubble .highcharts-data-label {
    cursor: pointer;
  }

  tr.close-event {
    background-color: #e8dcdc;
    opacity: 0.7;
  }
  #channels-table tr.close-event td {
    padding-top: 0;
    padding-bottom: 0;
    padding-left: 20px;
  }
</style>

<svelte:head>
  <title>node {node.name}</title>
  <meta
    name="description"
    content="{abbr(node.pubkey)}: {node.openchannels} channels, total capacity of {node.capacity} satoshis"
  />
</svelte:head>

<h1>
  node
  <pre class="id">{node.pubkey}</pre>
</h1>

<div class="flex-col">
  {#if aliases}
  <div>
    <h4>node names</h4>
    <table>
      <thead>
        <tr>
          <th>first seen</th>
          <th>alias</th>
        </tr>
      </thead>
      <tbody>
        {#each aliases as alias}
        <tr>
          <td>{date(alias.first_seen)}</td>
          <td>{alias.alias}</td>
        </tr>
        {/each}
      </tbody>
    </table>
  </div>
  {/if}

  <div>
    <table>
      <tbody>
        <tr>
          <th>open channels</th>
          <td>{node.openchannels}</td>
        </tr>
        <tr>
          <th>closed channels</th>
          <td>{node.closedchannels}</td>
        </tr>
        <tr>
          <th>avg channel duration</th>
          <td>{node.avg_duration}</td>
        </tr>
        <tr>
          <th>avg opening fee</th>
          <td>{node.avg_open_fee}</td>
        </tr>
        <tr>
          <th>avg closing fee</th>
          <td>{node.avg_close_fee}</td>
        </tr>
        <tr>
          <th>capacity</th>
          <td>{node.capacity}</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<div>
  <h4>channel variation</h4>
  <div id="channels-history" bind:this="{chartHistory}" />
</div>

<div>
  <h4>current channels</h4>
  <div id="channels-bubble" bind:this="{chartBubbles}" />
</div>

<div>
  <h4>all channels</h4>
  <table id="channels-table">
    <thead>
      <tr>
        <th>with</th>
        <th>id</th>
        <th>total satoshis</th>
        <th>chain fee</th>
        <th>open</th>
        <th>close</th>
        <th>
          {#if direction == "outgoing"} ↗ {:else} ↙ {/if}
          <span class="toggle" on:click="{toggleDirection}">
            {direction}
          </span>
          fee policy
        </th>
      </tr>
    </thead>
    <tbody>
      {#each channels as channel}
      <tr
        id="ch-{channel.short_channel_id}"
        class:closed="{channel.close_block > 0}"
      >
        <td data-size="{channel.peer_size}">
          <a href="/node/{channel.peer_id}">
            {#if channel.peer_name} {channel.peer_name} {:else}
            {abbr(channel.peer_id)} {/if}
          </a>
        </td>
        <td>
          <a href="/channel/{channel.short_channel_id}">
            {channel.short_channel_id}
          </a>
        </td>
        <td>
          {channel.satoshis}
          <i
            class="bar"
            style="width:{(100 * (channel.satoshis / maxcap)).toFixed(2)}%; background: var(--gold)"
          />
        </td>
        <td
          title="{(100 * (channel.open_fee + channel.close_fee) / channel.satoshis).toFixed(2)}% of total value"
        >
          {channel.open_fee} {#if channel.close_block > 0} + {channel.close_fee}
          = {channel.open_fee + channel.close_fee} {/if}

          <i
            class="bar"
            style="width:{(100 * (channel.open_fee + channel.close_fee) / maxfee).toFixed(2)}%; background: var(--gold)"
          />
        </td>
        <td>{channel.open_block}</td>
        <td>{#if channel.close_block > 0} {channel.close_block} {/if}</td>
        {#if channel.close_block > 0}
        <td>
          {#if channel.close_type}closed as
          <strong>{channel.close_type}</strong>{/if} {#if
          channel.close_htlc_count > 0}with {channel.close_htlc_count} HTLC{#if
          channel.close_htlc_count != 1}s{/if} {/if}
        </td>
        {:else}
        <td class:hidden="{direction !== 'outgoing'}">
          {channel.outgoing_fee_per_millionth / 10000}% (min
          {(channel.outgoing_base_fee_millisatoshi / 1000).toFixed(3)} sat);
          delay of {channel.outgoing_delay}
        </td>
        <td class:hidden="{direction !== 'incoming'}">
          {channel.incoming_fee_per_millionth / 10000}% (min
          {(channel.incoming_base_fee_millisatoshi / 1000).toFixed(3)} sat);
          delay of {channel.incoming_delay}
        </td>
        {/if}
      </tr>
      {/each}
    </tbody>
  </table>
</div>
